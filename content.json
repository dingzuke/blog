{"meta":{"title":"Ding Zuke's blog","subtitle":"个人博客","description":"一个web开发者的爬坑路","author":"丁祖科","url":"https://www.ding51.cn"},"pages":[{"title":"","date":"2020-05-22T09:00:23.407Z","updated":"2020-05-22T09:00:23.407Z","comments":true,"path":"google5d9a7416b18345fe.html","permalink":"https://www.ding51.cn/google5d9a7416b18345fe.html","excerpt":"","text":"google-site-verification: google5d9a7416b18345fe.html"},{"title":"about","date":"2018-11-13T02:55:06.000Z","updated":"2020-05-22T09:00:23.406Z","comments":true,"path":"about/index.html","permalink":"https://www.ding51.cn/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-11-14T06:06:53.000Z","updated":"2020-05-22T09:00:23.406Z","comments":true,"path":"categories/index.html","permalink":"https://www.ding51.cn/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-11-14T06:07:40.000Z","updated":"2020-05-22T09:00:23.424Z","comments":true,"path":"tags/index.html","permalink":"https://www.ding51.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"js事件流","slug":"js事件流","date":"2019-12-31T08:26:13.000Z","updated":"2020-06-12T06:44:26.123Z","comments":true,"path":"js-shi-jian-liu.html","link":"","permalink":"https://www.ding51.cn/js-shi-jian-liu.html","excerpt":"","text":"js事件流概念:HTML中与javascript交互是通过事件驱动来实现的，例如鼠标点击事件、页面的滚动事件onscroll等等,当页面产生一个事件时,该事件会在元素节点与根节点之间的路径传播，路径所经过的节点都会收到该事件，这个传播的过程叫做DOM事件流一. 当页面产生一个事件时经过的三个阶段: 事件捕获阶段document顶部先接收到事件，依次往下传播到事件节点（可以借用addEventListener来模拟事件捕获流） 处于目标阶段 事件冒泡阶段事件开始时由最具体的元素接收，然后逐级向上传播执行流程: 示例代码:说明: addEventListener 第一个参数: 事件名称, 第二个参数: 触发函数, 第三个参数: 布尔 默认false, true表示捕获阶段触发, fals事件冒泡阶段 三：js阻止事件冒泡和默认事件阻止事件冒泡:w3c:e.stopPropagationie:window.event.cancelBubble = true 默认事件：是指目标元素的默认行为比如a标签会跳转链接 form会提交表单w3c:e.preventDefault()ie:window.event.returnValue = false 另外js中的return false也可以阻止默认行为,jq中的return false既可以阻止默认行为也可以阻止冒泡 // 事件绑定的方式, 用return false; 不会阻止默认事件 oBtn.addEventListener('click', function (e) { console.log('btn处于事件冒泡阶段 - 5'); return false; }, false); // 以下代码 return false;可以阻止 oBtn.onclick = function () { return false; }; return false 参考文章","categories":[],"tags":[]},{"title":"节流和防抖","slug":"节流和防抖","date":"2019-12-18T07:51:00.000Z","updated":"2020-05-22T09:00:23.406Z","comments":true,"path":"jie-liu-he-fang-dou.html","link":"","permalink":"https://www.ding51.cn/jie-liu-he-fang-dou.html","excerpt":"","text":"函数防抖(debounce)含义: 在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。 debounce 使用场景 search搜索联想，用户在不断输入值时，用防抖来节约请求资源。 window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次 频繁操作点赞和取消点赞，因此需要获取最后一次操作结果并发送给服务器 代码示例: &lt;Input placeholder=\"搜索\" onClick={this.debounce(this.handleSearch, 400)}/> /** * 防抖函数--异步搜索 */ private debounce = (fn: Function, delay: number = 500) => { let timeout = null; let _this = this; return function() { let args = arguments; clearTimeout(timeout); timeout = setTimeout(() => { fn.apply(_this, args); }, delay); }; } 函数节流(throttle)含义: 规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。 throttle使用场景 鼠标不断点击触发，mousedown(单位时间内只触发一次) 监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断 代码示例: /** * 节流函数 */ private throttle = (fn: Function, delay: number = 500) => { let _this = this; let isRuning = false; return function () { let args = arguments; if (isRuning) { return; } isRuning = true; setTimeout(() => { isRuning = false; fn.apply(_this, args); }, delay); }; } 总结：函数防抖： 将多次操作合并为一次操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。 函数节流： 使得一定时间内只触发一次函数。原理是通过判断是否有延迟调用函数未执行","categories":[{"name":"js","slug":"js","permalink":"https://www.ding51.cn/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://www.ding51.cn/tags/js/"},{"name":"防抖","slug":"防抖","permalink":"https://www.ding51.cn/tags/防抖/"},{"name":"节流","slug":"节流","permalink":"https://www.ding51.cn/tags/节流/"}]},{"title":"小程序web-view中使用JSSDK,ios安卓踩坑","slug":"web-view-react中JSSDK","date":"2019-12-17T10:41:00.000Z","updated":"2020-05-22T09:00:23.406Z","comments":true,"path":"web-view-react-zhong-jssdk.html","link":"","permalink":"https://www.ding51.cn/web-view-react-zhong-jssdk.html","excerpt":"","text":"背景: 在小程序中使用web-view使用react,需要调用相关JSSDK的接口配置, IOS能正常使用,安卓却签名错误invalid signature基础配置按照官方文档来, 这里说明下配置注意事项: 引入微信jssdk，wx.config所用到的工具函数，appid 要使用公众号的APPID，如果APPID使用的是小程序的APPID，config时会报签名无效，要注意config签名参数的大小写 在公众号里面配置,js安全域名配置成web-view的域名 以上配置成功后, 在IOS中使用都能正常使用, 却在安卓机器上使用签名失败invalid signature, 硬是没在网上找到相关解决方案, 很多都是安卓使用正常, IOS使用异常. 煎熬两天综合了其他问题,经过尝试终于通了,记录一下解决方案, 希望帮助遇到同样问题的人 &lt;script type=\"text/javascript\" src=\"https://res.wx.qq.com/open/js/jweixin-1.3.2.js\">&lt;/script> &lt;script> // web-view进入react的第一时间, index.html时记录url if (typeof window.entryUrl === 'undefined' || window.entryUrl === '') { window.entryUrl = location.href.split('#')[0]; } &lt;/script> // 发送给后端签名时 这里就需要区分了!! let isAnd = /(Android)/i.test(navigator.userAgent); //安卓终端 let url = isAnd ? encodeURIComponent(window['entryUrl']) : encodeURIComponent(location.href.split('/?')[0]); 分析: 我这里进入web-view的地址是https://dev.xxx.com?openId=xxx&amp;token=xxxx 然后进入默认路由页面url已经变成https://dev.xxx.com/workbench?appkey=xxx SPA 的router路由机制,在安卓和ios的不同, jssdk url签名的ios只认第一次的路由，我只需要传第一次路由给后端就行","categories":[{"name":"小程序","slug":"小程序","permalink":"https://www.ding51.cn/categories/小程序/"}],"tags":[{"name":"JSSDK","slug":"JSSDK","permalink":"https://www.ding51.cn/tags/JSSDK/"},{"name":"小程序","slug":"小程序","permalink":"https://www.ding51.cn/tags/小程序/"}]},{"title":"git常用的指令","slug":"git常用到的指令","date":"2019-03-27T18:44:00.000Z","updated":"2020-05-22T09:00:23.405Z","comments":true,"path":"git-chang-yong-dao-de-zhi-ling.html","link":"","permalink":"https://www.ding51.cn/git-chang-yong-dao-de-zhi-ling.html","excerpt":"","text":"开发时常用的指令1. github配置 ssh key配置cd ~/.ssh 查看是否有id_rsa、id_rsa.pub文件，如果没有需要手动生成。 ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 一路回车.登录github。打开setting-&gt;SSH keys，点击右上角 New SSH key，把生成好的公钥id_rsa.pub放进 key输入框中 2. git常用命令git branch //显示分支一览表，同时确认当前所在的分支git checkout -b aaa //创建名为aaa的分支，并且切换到aaa分支 //创建名为aaa的分支git checkout aaa // 切换到aaa分支git checkout - //切换到上一分支 不小心commit了一个不应该commit的修改，但是还没有push，想回滚那个commit.命令：git log // 查看提交日志 复制下commit_idgit reset --hard commit_id // 回滚 查看更改的记录(后面可以加具体的文件名)git diff 合并本地 分支代码git merge test // test为合并进来的分支 远程仓库查看git remote -v 添加远程仓库git remote add upstream https://github.com/xxxxx/kts-portal.git 重置远程仓库路径git remote set-url upstream https://github.com/xxxxxx/SpringBoot.git 更新远程分支列表git remote update origin --prunegit remote update origin -p 拉取远程某个分支git pull upstream dev","categories":[{"name":"git","slug":"git","permalink":"https://www.ding51.cn/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.ding51.cn/tags/git/"}]},{"title":"对数组中的某对象排序","slug":"数组中的某对象排序","date":"2019-03-25T15:45:00.000Z","updated":"2020-05-22T09:00:23.406Z","comments":true,"path":"shu-zu-zhong-de-mou-dui-xiang-pai-xu.html","link":"","permalink":"https://www.ding51.cn/shu-zu-zhong-de-mou-dui-xiang-pai-xu.html","excerpt":"","text":"利用sort方法排序例子: 对一组数组中的年龄排序. var arr = [ {name:'zopp',age:0}, {name:'gpp',age:18}, {name:'yjj',age:8} ]; // 降序 function compare(name){ return function(a,b){ return a[name] - b[name]; } } // 打乱数组顺序 function disrupt(name){ return function(a,b){ return Math.random() > 0.5 ? -1 : 1; } } console.log(arr.sort(compare('age'))) 结果,: [ {name:&#39;zopp&#39;,age:0}, {name:&#39;yjj&#39;,age:8} {name:&#39;gpp&#39;,age:18}, ];","categories":[{"name":"js","slug":"js","permalink":"https://www.ding51.cn/categories/js/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://www.ding51.cn/tags/排序/"}]},{"title":"node版本升级管理","slug":"ode版本升级管理","date":"2019-03-24T14:38:00.000Z","updated":"2020-05-22T09:00:23.405Z","comments":true,"path":"ode-ban-ben-sheng-ji-guan-li.html","link":"","permalink":"https://www.ding51.cn/ode-ban-ben-sheng-ji-guan-li.html","excerpt":"","text":"升级或降级node,网上找了一大堆的资料,看着头皮发麻,只需两行代码的事情 1. sudo npm install -g n // 安装 2. sudo n v9.10.0 // 升级到某个版本 如:v9.10.0 3. sudo n stable // 升级到最稳当版本","categories":[{"name":"node","slug":"node","permalink":"https://www.ding51.cn/categories/node/"}],"tags":[{"name":"node","slug":"node","permalink":"https://www.ding51.cn/tags/node/"}]},{"title":"如何创建发布NPM包?","slug":"创建发布NPM包","date":"2019-01-29T23:59:00.000Z","updated":"2020-05-22T09:00:23.406Z","comments":true,"path":"chuang-jian-fa-bu-npm-bao.html","link":"","permalink":"https://www.ding51.cn/chuang-jian-fa-bu-npm-bao.html","excerpt":"","text":"前言: 平时我们都是使用的别人写好的npm包, npm i xxx ,就直接安装好了使用,本文章介绍的是如何创建自己的封装好的npm包发布。 npm官网创建npm账户npm网站地址：https://www.npmjs.com/ 命令行工具登录npm npm login 验证登录是否成功 npm who am i如果成功会输入你npm个人信息 内镜检测: npm config get registry 如果输出 http://registry.npmjs.org就配置正确, 否则要设置镜像npm config set registry http://registry.npmjs.org 创建npm库npm init接下来就是一长串表单： name：填写你这个包的名字，默认是你这个文件夹的名字。不过这里要着重说一下，最好先去npm上找一下有没有同名的包。最好的测试方式就是，在命令行里面输入npm install 你要取的名字，如果报错，那么很好，npm上没有跟你同名的包，你可以放心大胆地把包发布出去。如果成功下载下来了。。。那么很不幸，改名字吧。。。 version：你这个包的版本，默认是1.0.0 description：其实我也不知道是什么，按回车就好了。。。，这个用一句话描述你的包是干嘛用的，比如我就直接：‘a plugin for express.register routes base on file path’ entry point：入口文件，默认是Index.js，你也可以自己填写你自己的文件名 test command：测试命令，这个直接回车就好了，因为目前还不需要这个。 git repository：这个是git仓库地址，如果你的包是先放到github上或者其他git仓库里，这时候你的文件夹里面会存在一个隐藏的.git目录，npm会读到这个目录作为这一项的默认值。如果没有的话，直接回车继续。 keyword：这个是一个重点，这个关系到有多少人会搜到你的npm包。尽量使用贴切的关键字作为这个包的索引。我这个包嘛，第一是在express下工作的，然后又是一个插件plugin，然后又是一个注册路由route用的，而这个路由又是基于文件目录dir，所以很好就得出我的包的索引关键字。 author：写你的账号或者你的github账号吧 license：这个直接回车，开源文件来着。。。然后它就会问你Are you ok? 直接回车最后生成package.json 同级目录下新建index.js并编写内容 exports.sayHello=function(){ return \"Hello.\"; }; 发布npm包 npm publish发布完成会提示 验证是否发布成功 npm install xxx包 更新版本npm version &lt;update_type&gt; -m &quot;&lt;message&gt;&quot;其中update_type 有三种：patch增加一位补丁号（比如 1.1.1 -&gt; 1.1.2）minor增加一位小版本号（比如 1.1.1 -&gt; 1.2.0）major增加一位大版本号（比如 1.1.1 -&gt; 2.0.0）比如：npm version patch -m &quot;Version %s - v1.0.2&quot;最后提交更新的版本：npm publish 撤销自己发布的版本。这只是一个测试的包，最好当然还是撤销下来npm --force unpublish test_npm 注: 删除要用force强制删除。超过24小时就不能删除了","categories":[{"name":"npm","slug":"npm","permalink":"https://www.ding51.cn/categories/npm/"}],"tags":[{"name":"创建npm包","slug":"创建npm包","permalink":"https://www.ding51.cn/tags/创建npm包/"}]},{"title":"JS如何优雅的写判断语句(二)","slug":"JS如何优雅的写判断语句-二","date":"2019-01-20T20:01:00.000Z","updated":"2020-05-22T09:00:23.404Z","comments":true,"path":"js-ru-he-you-ya-de-xie-pan-duan-yu-ju-er.html","link":"","permalink":"https://www.ding51.cn/js-ru-he-you-ya-de-xie-pan-duan-yu-ju-er.html","excerpt":"","text":"1.多重判断时使用 Array.includes2.更少的嵌套，尽早 return3.使用默认参数和解构4.倾向于遍历对象而不是 Switch 语句5.对 所有/部分 判断使用 Array.every &amp; Array.some 1.多重判断时使用 Array.includes例子: function test(fruit) { if (fruit == 'apple' || fruit == 'strawberry') { console.log('red'); } } 用 Array.includes (Array.includes)重写条件语句 function test(fruit) { const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries']; if (redFruits.includes(fruit)) { console.log('red'); } } 把条件放入数组,利用includes判断,这样一来，代码看起来更整洁 2.更少的嵌套，尽早 Return例子: function test(fruit, quantity) { const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries']; // 条件 1: fruit 必须有值 if (fruit) { // 条件 2: 必须是red的 if (redFruits.includes(fruit)) { console.log('red'); // 条件 3: quantity大于10 if (quantity > 10) { console.log('big quantity'); } } } else { throw new Error('No fruit!'); } } // 测试结果 test(null); // error: No fruits test('apple'); // print: red test('apple', 20); // print: red, big quantity 当发现无效语句时，尽早Return,少嵌套 function test(fruit, quantity) { const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries']; // 条件 1: 尽早抛出错误 if (!fruit) throw new Error('No fruit!'); // 条件 2: 当水果不是红色时停止继续执行 if (!redFruits.includes(fruit)) return; console.log('red'); // 条件 3: 必须是大质量的 if (quantity > 10) { console.log('big quantity'); } } 3.使用默认参数和解构需要检查 null / undefined的值和指定默认值,例子: // fruit是一个对象{name: 'xx'} , quantity数量设置默认值为 1 function test(fruit, quantity) { // 如果 quantity 参数没有传入，设置默认值为 1 const q = quantity || 1; // 当值存在时打印 fruit 的值 if (fruit &amp;&amp; fruit.name){ console.log(`We have ${quantity} ${fruit.name}!`); }else { console.log('unknown'); } } 使用默认参数和解构 代替 // fruit是一个对象{name: 'xx'} , quantity数量 function test({name} = {}, quantity = 1) { console.log (name || 'unknown'); } 4.倾向于对象遍历而不是if/else Switch语句利用对象代替,可以参考上一篇文章 const fruitColor = { red: ['apple', 'strawberry'], yellow: ['banana', 'pineapple'], purple: ['grape', 'plum'] }; function test(color) { return fruitColor[color] || []; } 5.对 所有/部分 判断使用Array.every &amp; Array.somees6中every,当数组中的数据必须每个满足条件返回true var computers = [ {name:\"Apple\",ram:8}, {name:\"IBM\",ram:4}, {name:\"Acer\",ram:32}, ]; computers.every(computer => computer.ram > 3) // true computers.every(computer => computer.ram > 10) // false some,当数组中只要一条数据满足条件,就返回true var computers = [ {name:\"Apple\",ram:8}, {name:\"IBM\",ram:4}, {name:\"Acer\",ram:32}, ]; computers.some(computer => computer.ram > 8) // true computers.some(computer => computer.ram > 32) // false","categories":[],"tags":[{"name":"js优化","slug":"js优化","permalink":"https://www.ding51.cn/tags/js优化/"}]},{"title":"JS如何优雅的写判断语句(一)","slug":"JS如何优雅的写判断语句","date":"2019-01-20T17:25:00.000Z","updated":"2020-05-22T09:00:23.404Z","comments":true,"path":"js-ru-he-you-ya-de-xie-pan-duan-yu-ju.html","link":"","permalink":"https://www.ding51.cn/js-ru-he-you-ya-de-xie-pan-duan-yu-ju.html","excerpt":"","text":"一.复杂判断优雅写法前言:js代码时经常遇到复杂逻辑判断的情况，通常大家可以用if/else或者switch来实现多个条件判断，但这样会有个问题，随着逻辑复杂度的增加，代码中的if/else/switch会变得越来越臃肿，越来越看不懂。 1.1 一元条件判断一般的写法 if/else 或者 switch/** * @param {number} status 活动状态：1 开团进行 2 开团失败 3 商品售罄 4 开团成功 5 系统取消 */ const onButtonClick = (status) =>{ if (status === 1) { sendLog('processing') jumpTo('IndexPage') } else if (status === 2) { sendLog('fail') jumpTo('FailPage') } else if (status === 3) { sendLog('fail') jumpTo('FailPage') } else if (status === 4) { sendLog('success') jumpTo('SuccessPage') } else if (status === 5) { sendLog('cancel') jumpTo('CancelPage') } else { sendLog('other') jumpTo('Index') } } 优化方法一,将判断条件作为对象的属性名，将处理逻辑作为对象的属性值 const actions = { '1': ['processing', 'IndexPage'], '2': ['fail', 'FailPage'], '3': ['fail', 'FailPage'], '4': ['success', 'SuccessPage'], '5': ['cancel', 'CancelPage'], 'default': ['other', 'Index'], } const onButtonClick = (status) = >{ let action = actions[status] || actions['default'], let logName = action[0], let pageName = action[1]; sendLog(logName); jumpTo(pageName); } 优化方法二,es6里的Map对象 const actions = new Map([ [1, ['processing', 'IndexPage']], [2, ['fail', 'FailPage']], [3, ['fail', 'FailPage']], [4, ['success', 'SuccessPage']], [5, ['cancel', 'CancelPage']], ['default', ['other', 'Index']]]) const onButtonClick = (status) => { let action=actions.get(status)||actions.get('default'); sendLog(action[0]); jumpTo(action[1]); } 1.2 多条件同时判断多条件普通写法 if/elseconst onButtonClick = (status, identity) => { if (identity == 'guest') { if (status == 1) { } else if (status == 2) { } else if (status == 3) { } else if (status == 4) { } else if (status == 5) { } else {} } else if (identity == 'master') { if (status == 1) { } else if (status == 2) { } else if (status == 3) { } else if (status == 4) { } else if (status == 5) { } else {} } } 优化写法一: 利用对象object 或者 map // 利用object对象 字符串拼接 const actions = { 'guest_1': () = >{}, 'guest_2': () = >{}, //.... } const onButtonClick = (identity, status) => { let action = actions[`$ {identity}_${status}`] || actions['default']; action.call(this); } // 利用map对象 字符串拼接 const actions=new Map([ ['guest_1',()=>{}], ['guest_2',()=>{}], ['master_1',()=>{}], ['master_2',()=>{}], ['default',()=>{}], ]); const onButtonClick = (identity, status) => { let action = actions.get(`$ {identity}_${status}`) || actions.get('default'); action.call(this); } 不拼接优化方法二: 用Map对象，以Object对象作为key const actions = new Map([ [{identity: 'guest',status: 1},() = >{}], [{identity: 'guest', status: 2}, () = >{}], ]) const onButtonClick = (identity, status) => { let action = [...actions].filter(([key, value]) =>(key.identity == identity &amp;&amp; key.status == status)); action.forEach(([key, value]) = >value.call(this)); } 注意: 不能直接actions.get({identity: &#39;guest&#39;,status: 1}).call(this)调用 会报错,因为{identity: ‘guest’,status: 1},和map中定义的不是指的同一个对象地址","categories":[],"tags":[{"name":"js优化","slug":"js优化","permalink":"https://www.ding51.cn/tags/js优化/"},{"name":"map对象","slug":"map对象","permalink":"https://www.ding51.cn/tags/map对象/"}]},{"title":"input只能输入数字并限制长度","slug":"input只能输入数字并限制长度","date":"2018-12-26T14:01:00.000Z","updated":"2020-05-22T09:00:23.405Z","comments":true,"path":"input-zhi-neng-shu-ru-shu-zi-bing-xian-zhi-chang-du.html","link":"","permalink":"https://www.ding51.cn/input-zhi-neng-shu-ru-shu-zi-bing-xian-zhi-chang-du.html","excerpt":"","text":"随笔记录情景:要求只能输入数字,且限制长度,在谷歌浏览器移除input[number]的上下箭头样式 &lt;input type=&quot;text&quot; maxlength=&quot;5&quot; /&gt; 效果ok，当 &lt;input type=&quot;number&quot; maxlength=&quot;5&quot; /&gt;时maxlength失效，长度可以无限输入 解决参考代码: &lt;style> /*在chrome下移除input[number]的上下箭头*/ input::-webkit-outer-spin-button, input::-webkit-inner-spin-button{ -webkit-appearance: none !important; margin: 0; } /*在firefox下移除input[number]的上下箭头*/ input[type=\"number\"]{-moz-appearance:textfield;} &lt;style> &lt;input type=\"number\" oninput=\"if(value.length>5)value=value.slice(0,5)\">","categories":[{"name":"html5","slug":"html5","permalink":"https://www.ding51.cn/categories/html5/"}],"tags":[{"name":"htm5","slug":"htm5","permalink":"https://www.ding51.cn/tags/htm5/"},{"name":"css","slug":"css","permalink":"https://www.ding51.cn/tags/css/"}]},{"title":"React生命周期(v16.3 之前版本)","slug":"React新旧生命周期对比-v16-3","date":"2018-12-09T21:14:00.000Z","updated":"2020-05-22T09:00:23.405Z","comments":true,"path":"react-xin-jiu-sheng-ming-zhou-qi-dui-bi-v16-3.html","link":"","permalink":"https://www.ding51.cn/react-xin-jiu-sheng-ming-zhou-qi-dui-bi-v16-3.html","excerpt":"","text":"生命周期对react非常重要,对很多新手来说,搞不懂哪个阶段该做什么事情,迷茫,乱用函数,导致性能下降,死循环. 文章主要记录了react平时常用的生命周期函数,及平时开发遇到的注意事项,自从react v16.3更新后,其生命周期还是发生很大的改变, 这里介绍v16.3之前的版本 React 生命周期主要包括三个阶段：1. 初始化阶段2. 运行中阶段3. 销毁阶段(注:结合图来看文章有助理解) 1. 初始化阶段1-1.设置组件默认属性方法一 挂载组件的时候设置 props(比较常用) var data = [{title: 'Hello'}]; &lt;Hello data={data} /> 方法二 defaultProps在组件内部定义,此方法编译才生效,es6 会报错,使用es7以上(详情) static defaultProps = { age: 18 } 在组件外部属性定义 Greeting.defaultProps = { name: '我是props的默认值！' }; ReactDOM.render( &lt;Greeting />, document.getElementById('example') ); 1-2.组件的初始化状态 stateconstructor(props){ super(props); // 不加super()，导致了this的 Reference Error this.state={}; } super关键字，它指代父类的实例（即父类的this对象）。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。super(props):传递props作为super()的参数，那就是你需要在构造函数内使用this.props 1-3.componentWillMount因为componentWillMount是在render之前执行，所以在这个方法中setState不会发生重新渲染(re-render),通常情况下，推荐用constructor()方法代替.提示: 很多时候喜欢这里去做一些初始化数据的请求,你会发现数据还没请求到就渲染render()了,当请求到数据后setState再渲染出数据.依然重复渲染. 建议初始化数据都在componentDidMount()中使用,新版本将去掉这个函数. 1-4.render该方法会创建一个虚拟DOM，用来表示组件的输出。对于一个组件来讲，render方法是唯一一个必需的方法。render方法需要满足下面几点： 只能通过 this.props 和 this.state 访问数据（不能修改） 可以返回 null,false 或者任何React组件 只能出现一个顶级组件，不能返回一组元素 不能改变组件的状态 不能修改DOM的输出render方法返回的结果并不是真正的DOM元素，而是一个虚拟的表现，类似于一个DOM tree的结构的对象。 1-5. componentDidMount一般情况在这里做初始化异步数据请求 这个方法会在render()之后立即执行； 这里可以对DOM进行操作，这个函数之后ref变成实际的DOM 2. 组件运行阶段此时组件已经渲染好并且用户可以与它进行交互，比如鼠标点击，手指点按，或者其它的一些事件，导致应用状态的改变，你将会看到下面的方法依次被调用2-1.componentWillReceiveProps组件的 props 属性可以通过父组件来更改，这时，componentWillReceiveProps 将来被调用。可以在这个方法里更新 state,以触发 render 方法重新渲染组件。 componentWillReceiveProps: function(nextProps){ if(nextProps.checked !== undefined){ this.setState({ checked: nextProps.checked }) } } 2-2.shouldComponentUpdate(nextProps, nextState)在接收新的props或state时确定是否发生重新渲染，默认情况返回true，表示会发生重新渲染注意 这个方法在首次渲染时或者forceUpdate()时不会触发; 这个方法如果返回false, 那么props或state发生改变的时候会阻止子组件发生重新渲染; 目前，如果返回false, 那么componentWillUpdate(nextProps, nextState), render(), componentDidUpdate()都不会被触发; 2-3.componentWillUpdate在props或state发生改变或者shouldComponentUpdate(nextProps, nextState)触发后, 在render()之前.千万不要在这个函数中调用this.setState()方法,死循环.结合图表看.2-4.render同上 1-42-5.componentDidUpdate(object prevProps, object prevState)这个方法和 componentDidMount 类似 3.componentWillUnmount组件被销毁时触发。这里我们可以进行一些清理操作，例如清理定时器， 关闭抽屉弹框，取消Redux的订阅事件等等. 总结对比生命周期实例 demo","categories":[{"name":"react","slug":"react","permalink":"https://www.ding51.cn/categories/react/"}],"tags":[{"name":"react生命周期","slug":"react生命周期","permalink":"https://www.ding51.cn/tags/react生命周期/"}]},{"title":"ES6中箭头函数和function的区别","slug":"ES6中箭头函数和function的区别","date":"2018-11-27T13:45:00.000Z","updated":"2020-05-22T09:00:23.404Z","comments":true,"path":"es6-zhong-jian-tou-han-shu-he-function-de-qu-bie.html","link":"","permalink":"https://www.ding51.cn/es6-zhong-jian-tou-han-shu-he-function-de-qu-bie.html","excerpt":"","text":"箭头函数和function的区别总结1.箭头函数与function定义函数的写法//function function fn(a, b){ return a + b; } // 箭头函数 var foo = (a, b)=>{ return a + b }; 2.this的指向1.使用function定义的函数，this的指向随着调用环境的变化而变化的。 //使用function定义的函数 function foo(){ console.log(this); } var obj = { aa: foo }; foo(); //Window obj.aa() //obj { aa: foo } 2.而箭头函数中的this指向是固定不变的，一直指向的是定义函数的环境，最近的作用域(个人理解)。 //使用箭头函数定义函数 var foo = () => { console.log(this) }; var obj = { aa:foo }; foo(); //Window obj.aa(); //Window let a = { foo: 1, bar: () => console.log(this.foo) } a.bar() //undefined 原因:箭头函数中的this并不是指向a这个对象。对象a并不能构成一个作用域，所以再往上到达全局作用域，this就指向全局作用域,这里this指向Window。 3.构造函数//使用function方法定义构造函数 function Person(name, age){ this.name = name; this.age = age; } var lenhart = new Person(lenhart, 25); console.log(lenhart); //{name: 'lenhart', age: 25} function是可以定义构造函数的，而箭头函数是不行的。 //尝试使用箭头函数 var Person = (name, age) =>{ this.name = name; this.age = age; }; var lenhart = new Person('lenhart', 25); //Uncaught TypeError: Person is not a constructor 4.变量提升由于js的内存机制，function的级别最高，而用箭头函数定义函数的时候，需要var(let const定义的时候更不必说)关键词，而var所定义的变量不能得到变量提升，故箭头函数一定要定义于调用之前！ foo(); //123 function foo(){ console.log('123'); } arrowFn(); //Uncaught TypeError: arrowFn is not a function var arrowFn = () => { console.log('456'); };","categories":[{"name":"ES6","slug":"ES6","permalink":"https://www.ding51.cn/categories/ES6/"}],"tags":[{"name":"js","slug":"js","permalink":"https://www.ding51.cn/tags/js/"},{"name":"箭头函数this","slug":"箭头函数this","permalink":"https://www.ding51.cn/tags/箭头函数this/"},{"name":"ES6","slug":"ES6","permalink":"https://www.ding51.cn/tags/ES6/"}]},{"title":"Nginx 搭建和配置","slug":"Nginx-搭建和配置","date":"2018-11-21T02:01:00.000Z","updated":"2020-05-22T09:00:23.404Z","comments":true,"path":"nginx-da-jian-he-pei-zhi.html","link":"","permalink":"https://www.ding51.cn/nginx-da-jian-he-pei-zhi.html","excerpt":"","text":"本文章适合新手,其中含有我在实际中遇到的问题解决分享,服务器在搬瓦工租的,不多废话直接上干货 环境： 操作系统：CenOS 6 x86 Nginx 版本：1.14.0 Nginx搭建1.第一步 创建源配置在/etc/yum.repos.d/目录下创建一个源配置文件nginx.repo cd /etc/yum.repos.d/ vim nginx.repo 填写如下内容： [nginx] name=nginx repo baseurl=http://nginx.org/packages/centos/$releasever/$basearch/ gpgcheck=0 enabled=1 保存，则会产生一个/etc/yum.repos.d/nginx.repo文件。 2.第二步 安装直接执行如下指令即可自动安装好Nginx： yum install nginx -y 安装完成，下面直接就可以启动Nginx了： /etc/init.d/nginx start 现在Nginx已经启动了，直接访问服务器就能看到Nginx欢迎页面了的。如果还无法访问:方法一:查看下服务器上端口是否80(阿里云上配下80端口)。方法二:需配置一下Linux防火墙,以此执行如下命令: iptables -I INPUT 5 -i eth0 -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT service iptables save service iptables restart Nginx的相关命令： /etc/init.d/nginx start # 启动Nginx服务 /etc/init.d/nginx stop # 停止Nginx服务 /etc/nginx/nginx.conf # Nginx配置文件位置 chkconfig nginx on #设为开机启动 第三步 前端小优化 nginx开启gzip和缓存配置 (nginx.conf)进入nginx 配置文件vim /etc/nginx/nginx.conf,添加如下配置: # 开启gzip gzip on; # 启用gzip压缩的最小文件，小于设置值的文件将不会压缩 gzip_min_length 1k; # gzip 压缩级别，1-10，数字越大压缩的越好，也越占用CPU时间，后面会有详细说明 gzip_comp_level 2; # 进行压缩的文件类型。javascript有多种形式。其中的值可以在 mime.types 文件中找到。 gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png font/ttf font/otf image/svg+xml; # 是否在http header中添加Vary: Accept-Encoding，建议开启 gzip_vary on; # 禁用IE 6 gzip gzip_disable \"MSIE [1-6]\\.\"; # 开启缓存 location ~* ^.+\\.(ico|gif|jpg|jpeg|png)$ { access_log off; expires 30d; } location ~* ^.+\\.(css|js|txt|xml|swf|wav)$ { access_log off; expires 24h; } location ~* ^.+\\.(html|htm)$ { expires 1h; } location ~* ^.+\\.(eot|ttf|otf|woff|svg)$ { access_log off; expires max; } # 格式 # expires 30s; # expires 30m; # expires 2h; # expires 30d; 相关报错问题处理1.vim使用报错:-bash: vim: command not found 使用命令 : yum -y install vim* 2.解决Nginx下使用React-router(其他单页应用vue-router路由)刷新出现404问题server需要重定向到index ,进入配置 vim /etc/nginx/conf.d/default.conf server { listen 80; server_name zlzkj.io; index index.html; root /Volumes/Mac/www/antd-admin/; location / { try_files $uri $uri/ /index.html; // 指向index.html } } 至此，Nginx已经全部配置安装完成,如有问题欢迎留言或联系。","categories":[{"name":"服务器","slug":"服务器","permalink":"https://www.ding51.cn/categories/服务器/"}],"tags":[{"name":"Nginx ","slug":"Nginx","permalink":"https://www.ding51.cn/tags/Nginx/"}]}]}